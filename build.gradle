apply plugin: 'idea'
apply plugin: 'kotlin'
apply plugin: 'application'


repositories {
    mavenLocal()
    jcenter()
}

buildscript {
    ext.kotlin_version = '1.2.60'
    repositories {
        jcenter()
    }
    dependencies {
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
    }
}

def dllDirectory = 'build/dll'

applicationDefaultJvmArgs = [
        "-Djna.library.path=" + dllDirectory,
        "-Djava.library.path=" + dllDirectory,
        "-Duser.dir=MY_WORKING_DIR",
        "-XX:+UseG1GC",
        "-Xms256m"
]

// https://www.mkyong.com/gradle/gradle-application-plugin-app_home-in-applicationdefaultjvmargs/
startScripts {
    doLast {
        windowsScript.text = windowsScript.text.replace('MY_WORKING_DIR', "%~dp0.")
    }
}

run {
    systemProperty 'java.library.path', dllDirectory
}

test {
    systemProperty 'java.library.path', dllDirectory
	exclude 'tarehart/rlbot/integration/**'
}

dependencies {
    // Fetch the framework jar file
    compile 'org.rlbot.commons:framework:1.+'

    compile "org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlin_version"
    compile group: 'com.intellij', name: 'forms_rt', version: '7.0.3'
    compile group: 'com.google.code.gson', name: 'gson', version: '2.8.1'
    compile 'com.google.guava:guava:23.4-jre'
    compile group: 'org.ejml', name: 'ejml-ddense', version: '0.35'
    compile group: 'org.ejml', name: 'ejml-simple', version: '0.35'

    // This directory will be created and the interface dll copied into it at runtime.
    // The end result is that the interface dll will be on the classpath.
    runtime files(dllDirectory)

    testCompile group: 'junit', name: 'junit', version: '4.12'
    testCompile group: 'org.jfree', name: 'jfreechart', version: '1.5.0'
}

mainClassName = 'tarehart.rlbot.ReliefBotMainKt'

// You can run gradew distZip to generate a zip file suitable for tournament submissions
distZip {
    into ('README') {
        from 'README_Tournament.md'
        from fileTree('src/main/python') {
            exclude '__pycache__'
        }
    }
}

installDist {
    into ('../README') {
        from 'README_Tournament.md'
        from fileTree('src/main/python') {
            exclude '__pycache__'
        }
    }
}

compileKotlin {
    kotlinOptions {
        jvmTarget = "1.8"
    }
}
compileTestKotlin {
    kotlinOptions {
        jvmTarget = "1.8"
    }
}

task checkPipUpgradeSafety {
    doLast {
        new ByteArrayOutputStream().withStream { os ->
            def exitValue = exec {
                commandLine "python", "-c", "from rlbot.utils import public_utils; print(public_utils.is_safe_to_upgrade());"
                standardOutput = os
                ignoreExitValue = true
            }.exitValue

            // If the exit value is nonzero, the command  probably failed because rlbot is not installed at all.
            ext.isSafe = exitValue != 0 || os.toString().trim() == "True"
        }
    }
}


// Uses pip (the python package manager) to install all the python packages needed for this bot, as defined
// in requirements.txt.
task pipInstallRequirements {
    dependsOn 'checkPipUpgradeSafety'

    doLast {
        if (checkPipUpgradeSafety.isSafe) {
            exec {
                commandLine "python", "-m", "pip", "install", "-r", "./src/main/python/requirements.txt", "--upgrade"
            }
        } else {
            println 'Skipping upgrade attempt because files are in use.'
        }
    }
}

task createDllDirectory {
    mkdir dllDirectory
}

// Installs or updates RLBot. Empty task for now. It still does stuff because it "dependsOn" tasks that do things.
task updateRLBot {
    dependsOn 'pipInstallRequirements'
    dependsOn 'createDllDirectory'
}
